---
title: Skunk原理（字节序）
categories:
  - skunk
tags:
  - skunk
  - theory
abbrlink: 5ba1
date: 2020-05-03 04:39:48
---

聊聊字节序吧 [@leemaster](https://www.github.com/leemaster)

<!--more-->

> 我觉得这份Blog更多的是一个集全网所有字节序问题的一个集合Blog？我个人感觉这个字节序其实没有什么特别好讲和分析的，但是可能很多网上的Blog真的只是抛了砖，然后被疯狂转发，尤其是某技术论坛，也不知道到底第一篇分析这个的Blog是谁写出来的。本文的主要重点在第二章和第三章

# 字节序

关于这个名词的出现，其实和整个计算机的发展有很大的关系，我们现在用的个人PC基本都是X86架构的，可是在非常遥远的过去，基本都是各个厂商生产自己的指令集，然后把自己的指令集和自己的电路打包到一起，然后再为他们单独开发一个操作系统，销售给客户。这个历史背景也导致了，为什么现在这么多人爆锤C++。究其原因还是因为架构不兼容，不兼容的问题可以自己google一下，这个问题的对立面就是JVM，一次编写到处运行。

## 运行的抽象

但是虽然架构上是不兼容的，但是各大厂商又统一标准，定义了一个字节的长度为8位，那么字节序的问题从此就开始出现了。为什么这么说呢？因为电子计算机嘛，就是用来进行计算的，那么怎么计算呢？其实还有一个东西，就是算法，那么算法用什么描述呢？我们可以认为算法是一个指令序列，一条一条的执行，然后完成我们的计算任务就好了。那这些指令可以被看作什么呢？是的，可以被看作数据！那么我们怎么拿到数据呢？想想我们的外卖怎么被送到的，没错，就是地址！计算机通过地址拿到数据然后进行计算。那么这里就有了第一个问题什么是地址。

### 地址

我们完全可以想象，数据被存储在了一条超级长的磁带上，然后每一个位置都有一个标示符，来指示这个位置，那么这个标示符就是传说中的地址了。也就是我们的C语言中的指针。

### 寻址

计算机需要通过地址来进行寻址，这里不要想操作系统的那些什么段页内存管理，还有什么虚内存巴拉巴拉的，我们简单一点，给了一个地址，怎么定位到这个地址呢？

计算机其实还是一个现实的抽象，我们想想我们的住的小区，一般来说都是靠近某个门口的楼被标记成为了一号楼，这里我们认为这个楼叫做整个小区楼编号的起始位置，而整个小区的楼都是以这个一号楼为参考系建立的一个数轴。那么内存也是一样的，内存也有个`0x0000`位置，所有的内存区域都是根据这个`0x0000`位置作为参考系而建立起来的。

那么寻址呢？其实就是通过一些电路逻辑，找到起始的楼，然后通过一波操作最后指向了实际的内存块上面。

## 类型系统

重点来了，我们知道了什么是地址，怎么寻址，那么字节序有什么关系呢？这里就引出一个数字大小的问题，如果我们只用8个二进制位，我们能标示的数字范围其实只有`2^8-1`个数字，那么我们需要更大的数字了怎么办，那就用16个二进制位，32个二进制位，转换字节就是我们的数据可以被表示为，1字节，2字节，4字节，8字节（在C语言中就是这样的）。这也就是编译器知识中类型系统中——类型系统，我们的数据需要类型系统来约束，不然的话，编译器编译出来的代码不知道内存边界，也就不知道怎么解释这些数字，怎么在上面应用我们的计算规则。

正是有类型系统，所以才有了字节序问题，回到刚才说过的小区楼编号的问题，我现在住的小区是从东门开始编号（1，2，3，4...）但是我隔壁的小区却是从西门开始编号的（1，2，3，4...)。现在假设我们的两个小区的楼都长得一样，并且我们有某种工具可以直接把整个小区连根拔起来，我让我隔壁的小区放在我们小区的头上，看起来长得像这个样子了。

```
                      我  住  的  小  区
        +----------+---------+--------+---------+
        |    1     |    2    |   3    |    4    |
        |          |         |        |         |
        +----------+---------+--------+---------+
  东                                                  西
        +----------+---------+---------+--------+
        |    4     |    3    |    2    |   1    |
        |          |         |         |        |
        +----------+---------+---------+--------+
                     隔  壁  的  小  区

```

如果我把小区的楼看作一个一个的字节，那么整个小区就是一个内存条。大家的制作规则都是从东到西制作，但是呢，编号是不一样的，楼号对于人，就好像字节序对于CPU。我觉得我应该解释清楚这个东西了。

### 大小端

还记得上文我说过的历史问题嘛，在遥远的从前，所有的厂商标准都不一样，也导致了现在我们觉得C/C++总有些令人迷惑的地方，字节序只是一个问题，所以在Arpa网开发的时候，大家觉得这个太坑了，就强制的把网络字节序规定为了大端字节序。

解释大小端字节序，又不能不知道类型系统的东西，因为我们的内存字节是最小的单元，就好像原子一样，已经不能再分割了（不要跟我提里面还有夸克），那么如果对于一个字节其实没有什么问题，但是对于一个32位的整数呢？问题就来了，我们是从低地址向高地址读，只是我们从高地址向地址读呢？举个例子，对于一个数字`123`我们从左向右读，数值是一百二十三，如果我们从右向左读呢，就变成了三百二十一。惊不惊喜，意不意外？

就是这个从低地址到高地址还是从高地址到低地址的问题，各大厂商扯皮了很长时间，是的就是IBM，SUN，Berkeley...这帮人在扯皮。所以就被定义了一个新鲜的术语————字节序。

我们看个例子吧。

对于一个十六进制数字`0x12345678`，我们如果按照低地址到高地址存储，存储在内存中长这个样子`0x12345678`，读作 `12` `34` `56` `78`，符合正常的语言习惯，从左向右读。但是偏偏有人喜欢搞点事情，一定要在内存中存储`0x78563412`，那么我们要读取怎么读呢？是不是就需要从右向左读取了。

那么对于大小端，就可以直接理解为，小端表示`0x2345678`大端表示为`0x78563412`，关于学术上的定义，各位自行百度就好。

以上就是字节序的全部解释了。

## 令人迷惑的几个问题

在开发Skunk之前，我一直用Java或者Golang写一些网络编程，没有碰到过字节序的问题，所以也就没有关心过字节序的问题，但是在Skunk的设计中，就关注到了字节序问题，我提出了几个问题，并且自行解决了一下。

### 字符串还需要关心字节序嘛？

是的，网上没有任何一个博客讨论过这个问题，专业的书上也没有提过这个问题，估计很多程序员也没有想过这个问题。答案是不需要，为什么，因为我我们已经解释了什么是类型系统，通过上面的例子我们也能看出来，我们的大端字节序并不是`0x87654321`这种排列，而是`0x78563412`，因为大小端排列的是字节，并不是倒腾里面的数据，那么`char`这个东西本来就只有一个字节，即使是一个长的字符串，那么每个字符也是独立的，他们没有组合起来表示某种数据，所以字符串是不需要关心字节序的。

这里我们得到了一个推论，字节相互独立时不需要考虑字节序问题。

### UTF8编码需要关心字节序嘛？

UTF8 也是不用关心字节序问题的，因为UTF8 是按照字节进行单元编排的，一个UTF8字符如果需要用到后面的一位字符那么他会在信息内第一个字节中+1的。其实每个字节还是独立的，所以UTF8 完全可以表示成为字节数组，也就是每个字节独立的，他们之间没有任何关系。

### Skunk怎么做？

为了解决字节序问题，Linux已经提供了`endian.h`头文件专门处理字节序，所以Skunk直接把这些东西又包装了一遍，主要是为了提升语义。这些字节序操作函数都在`skunk/utility.h` 头文件中定义了，全部标记为了内联函数，在命名空间`skunk::endian`下，这些东西主要是提供给了`Buffer`对象去使用，`Buffer`对外提供的各种读写接口就不用关心字节序问题了。

```cpp
  namespace endian{
     inline uint16_t Host2NetUint16(uint16_t data){
        return htobe16(data);
     }
     inline uint32_t Host2NetUint32(uint32_t data){
        return htobe32(data);
     }
     inline uint64_t Host2NetUint64(uint64_t data){
        return htobe64(data);
     }
     inline uint16_t Host2NetUint16(int16_t data){
        return htobe16((unsigned)data);
     }
     inline uint32_t Host2NetUint32(int32_t data){
        return htobe32((unsigned)data);
     }
     inline uint64_t Host2NetUint64(int64_t data){
        return htobe64((unsigned)data);
     }

     inline uint16_t Net2HostUint16(uint16_t data){
        return be16toh(data);
     }
     inline uint32_t Net2HostUint32(uint32_t data){
        return be32toh(data);
     }
     inline uint64_t Net2HostUint64(uint64_t data){
        return be64toh(data);
     }
     inline int16_t Net2HostInt16(int16_t data){
        return (int16_t)be16toh((unsigned)data);
     }
     inline int32_t Net2HostInt32(uint32_t data){
        return (int32_t)be32toh((unsigned)data);
     }
     inline int64_t Net2HostInt64(uint64_t data){
        return (int64_t)be64toh((unsigned)data);
     }
  } 
```